<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>I made a promise</title>
        <link rel="stylesheet" href="styles.css">
    </head>
    <body>
        <nav id="navbar">
            <span
                style="display: flex; align-items: last baseline; justify-content: center; gap: 2vh;"><h2>I
                    made a <span class="cp">Promise</span></h2>
                </span></span>
                <a href="https://github.com/AndreiChristian" target="_blank"><svg width="30px" height="30px"
                        viewBox="0 -3.5 256 256"
                        xmlns="http://www.w3.org/2000/svg"
                        preserveAspectRatio="xMinYMin meet" fill="#ff5555"
                        stroke="#ff5555"><g id="SVGRepo_bgCarrier"
                            stroke-width="0"></g><g
                            id="SVGRepo_tracerCarrier" stroke-linecap="round"
                            stroke-linejoin="round"></g><g
                            id="SVGRepo_iconCarrier">
                            <g fill="#ff5555"> <path
                                    d="M127.505 0C57.095 0 0 57.085 0 127.505c0 56.336 36.534 104.13 87.196 120.99 6.372 1.18 8.712-2.766 8.712-6.134 0-3.04-.119-13.085-.173-23.739-35.473 7.713-42.958-15.044-42.958-15.044-5.8-14.738-14.157-18.656-14.157-18.656-11.568-7.914.872-7.752.872-7.752 12.804.9 19.546 13.14 19.546 13.14 11.372 19.493 29.828 13.857 37.104 10.6 1.144-8.242 4.449-13.866 8.095-17.05-28.32-3.225-58.092-14.158-58.092-63.014 0-13.92 4.981-25.295 13.138-34.224-1.324-3.212-5.688-16.18 1.235-33.743 0 0 10.707-3.427 35.073 13.07 10.17-2.826 21.078-4.242 31.914-4.29 10.836.048 21.752 1.464 31.942 4.29 24.337-16.497 35.029-13.07 35.029-13.07 6.94 17.563 2.574 30.531 1.25 33.743 8.175 8.929 13.122 20.303 13.122 34.224 0 48.972-29.828 59.756-58.22 62.912 4.573 3.957 8.648 11.717 8.648 23.612 0 17.06-.148 30.791-.148 34.991 0 3.393 2.295 7.369 8.759 6.117 50.634-16.879 87.122-64.656 87.122-120.973C255.009 57.085 197.922 0 127.505 0"></path>
                                <path
                                    d="M47.755 181.634c-.28.633-1.278.823-2.185.389-.925-.416-1.445-1.28-1.145-1.916.275-.652 1.273-.834 2.196-.396.927.415 1.455 1.287 1.134 1.923M54.027 187.23c-.608.564-1.797.302-2.604-.589-.834-.889-.99-2.077-.373-2.65.627-.563 1.78-.3 2.616.59.834.899.996 2.08.36 2.65M58.33 194.39c-.782.543-2.06.034-2.849-1.1-.781-1.133-.781-2.493.017-3.038.792-.545 2.05-.055 2.85 1.07.78 1.153.78 2.513-.019 3.069M65.606 202.683c-.699.77-2.187.564-3.277-.488-1.114-1.028-1.425-2.487-.724-3.258.707-.772 2.204-.555 3.302.488 1.107 1.026 1.445 2.496.7 3.258M75.01 205.483c-.307.998-1.741 1.452-3.185 1.028-1.442-.437-2.386-1.607-2.095-2.616.3-1.005 1.74-1.478 3.195-1.024 1.44.435 2.386 1.596 2.086 2.612M85.714 206.67c.036 1.052-1.189 1.924-2.705 1.943-1.525.033-2.758-.818-2.774-1.852 0-1.062 1.197-1.926 2.721-1.951 1.516-.03 2.758.815 2.758 1.86M96.228 206.267c.182 1.026-.872 2.08-2.377 2.36-1.48.27-2.85-.363-3.039-1.38-.184-1.052.89-2.105 2.367-2.378 1.508-.262 2.857.355 3.049 1.398"></path>
                            </g> </g></svg></a>
            </nav>
            <div id="progress-bar"></div>
            <section>
                <h1 style="color:#f5f5f5;">I made a <span style="color:#ff5555">Promise</span></h1>
                <p>"I made a promise and I am determined to solve the case!"
                    declared the detective with a sense of steely resolve. He
                    understood well that the mystery he was about to delve into
                    was
                    a complex one, requiring much more than what meets the eye.
                    The
                    stakes were high, the clues intricate, and time was of the
                    essence.</p>

                <p>Just as in the world of criminal investigation, programming
                    is a
                    field where tasks often require a significant amount of time
                    and
                    cannot be executed instantly. Dealing with such tasks isn't
                    as
                    simple as going from point A to point B. It's about managing
                    the
                    intricacies, handling the unexpected, and navigating the
                    complexities in a way that makes the most sense.</p>

                <p>In this story, we embark on a journey with the detective. We
                    will
                    assist him in performing a variety of tasks crucial to
                    solving
                    his case - decrypting mysterious codes, sifting through
                    piles of
                    files for that one piece of crucial evidence, unearthing
                    hidden
                    truths and so much more.</p>

                <p>But the detective isn't deterred by the magnitude of these
                    tasks.
                    Instead, he views them as challenges that test his mettle,
                    patience, and skills. And with every challenge he overcomes,
                    he
                    moves one step closer to solving the case.</p>

                <p>So, let's dive in and explore the detective's world of
                    promises,
                    callbacks, and the many fascinating aspects of programming.
                    Ready to crack the code? Let the investigation begin!</p>

            </section>
            <section>
                <h2>Chapter 1</h2>
                <h1>Introduction</h1>
            </section>
            <section>
                <p>Even the most skilled detective knows there is always room
                    for
                    improvement. There are always new methods and tools being
                    developed that make the process smoother, more efficient,
                    and
                    easier to manage.</p>
                <p>The same holds true for programming. In the world of
                    JavaScript,
                    a new construct was introduced to handle asynchronous tasks
                    more
                    elegantly - Promises. In the next chapter, we'll understand
                    what
                    they are, how they work, and how they make managing
                    asynchronous
                    operations much simpler.</p>
            </section>

            <section>
                <h2>Chapter 2</h2>
                <h1>A call back to the past</h1>
            </section>

            <section>
                <h2>Callbacks</h2>
                <p>This was not the first time the detective was facing cases
                    that
                    seemed impossible. His previous experience taught him one
                    thing:
                    use the right tool for the job! In his earlier days, the
                    detective relied heavily on callbacks to handle tasks. A
                    callback is a function passed into another function as an
                    argument, which is then invoked inside the outer function.
                    This
                    works fine when dealing with a single asynchronous task.</p>

                <p>However, as the detective's cases became more complex, he
                    found
                    himself dealing with multiple tasks that were dependent on
                    one
                    another. This led him to write more and more nested
                    callbacks,
                    which made his code harder to read and maintain, leading to
                    a
                    situation known as <span class="cp">"callback hell".</span></p>

                <span class="flex-row">
                    <pre><code>
    function investigateCrimeScene(callback) {
        // Task 1
        callback();
    }
        
    function listenToWitnesses(callback) {
        // Task 2
        callback();
    }
        
    function takeFingerPrints(callback) {
        // Task 3
        callback();
    }

    function lookForEvidence(callback) {
        // Task 4
        callback();
    }
        
    investiagetCrimeScene(function() {
        listenToWitnesses(function() {
            takeFingerPrints(function() {
                lookForEvidence(function(){
                    
                })
            });
        });
    });
            </code></pre>

                    <p>Here, each task requires the completion of the previous
                        task
                        before it can begin. As the number of dependent tasks
                        increases,
                        the code becomes deeply nested and harder to read and
                        manage.
                        This is a classic case of <span class="cp">"callback hell"</span>,
                        which our
                        detective
                        (and many programmers around the world) have struggled
                        with.</p>
                </span>
            </section>
            <section>
                <h2>Chapter 3</h2>
                <h1>The Promise of a Better Future</h1>
            </section>
            <section>

                <p>Even the most experienced detectives know when it's time to
                    update their toolbox. In the realm of JavaScript, the
                    introduction of Promises marked a significant upgrade from
                    callbacks.</p>
                <p>A Promise represents an operation that hasn't completed yet
                    but
                    is expected in the future. It's a placeholder of sorts for
                    the
                    eventual results of the operation. When it finishes, a
                    Promise
                    is either resolved (if the operation was successful) or
                    rejected
                    (if an error occurred).</p>

                <span class="flex-row">

                    <pre><code>
    const promiseToSolveCase = new Promise((resolve, reject) => {
          let caseSolved = false;
        
          // Simulating case solving process
          setTimeout(() => {
            caseSolved = true;
        
            if (caseSolved) {
              resolve('Case solved!');
            } else {
              reject('Failed to solve the case');
            }
          }, 2000);
        });
    

        
    promiseToSolveCase
    .then(successMessage => {
        console.log(successMessage);  // Logs 'Case solved!'
    })
    .catch(errorMessage => {
        console.log(errorMessage);
    });
            </code></pre>

                    <span class="flex-column">
                        <p>Promises make asynchronous code more readable and
                            easier to reason about. The Promise constructor
                            takes as
                            its
                            argument a function, known as the executor function,
                            that
                            takes
                            two parameters: `resolve` and `reject`. If the
                            operation
                            was
                            successful, `resolve` is called with the results. If
                            it
                            failed,
                            `reject` is called with the error.</p>

                        <p>Moreover, Promises also have built-in error handling.
                            The
                            `then`
                            method handles the case where the Promise is
                            resolved
                            and
                            the
                            `catch` method handles any errors. If an error is
                            thrown
                            anywhere along the Promise chain, it will be caught
                            and
                            handled
                            by the next `catch` in the chain.</p>
                    </span>
                </span>
            </section>
            <section>
                <h2>Chapter 4</h2>
                <h1>Connecting the Dots</h1>
            </section>
            <section>
                <p>Like any skilled detective, our hero knows the importance of
                    connecting the dots. In our case, these 'dots' are
                    asynchronous
                    operations that depend on each other's results. Promises
                    have an
                    elegant solution for this: chaining.</p>
                <p>With Promises, you can chain `then` callbacks together to
                    ensure
                    operations are performed in the correct order, each one
                    waiting
                    for the previous one to complete.</p>

                <!-- <span class="flex-row"> -->
                <pre><code>
            const searchForClues = new Promise((resolve, reject) => {
                // ...
                // This Promise simulates the process of searching for clues
            });
        
            const analyzeClues = new Promise((resolve, reject) => {
                // ...
                // This Promise simulates the process of analyzing clues
            });
        
            searchForClues
            .then(cluesFound => {
                console.log(cluesFound);
                return analyzeClues;
            })
            .then(analysisResult => {
                console.log(analysisResult);
            })
            .catch(error => {
                console.log(error);
            });
                </code></pre>

                <!-- <span class="flex-column"> -->
                <p>In this example, `searchForClues` is a Promise that
                    simulates the process of searching for clues. The `then`
                    method is called when `searchForClues` is resolved, and
                    its callback function logs the clues found and returns
                    `analyzeClues`, another Promise.</p>
                <p>This returned Promise is then automatically chained onto
                    the end of the Promise chain, and its results are passed
                    into the next `then` callback when it's resolved. This
                    way, we ensure that the clues are analyzed only after
                    they have been found.</p>
                <p>If any Promise in the chain is rejected, the `catch` at
                    the end of the chain is called, logging the error. This
                    way, if either searching for clues or analyzing them
                    fails, we catch and handle the error.</p>
                <!-- </span> -->
                <!-- </span> -->
            </section>

            <section>
                <h2>Chapter 5</h2>
                <h1>Assembling the Team</h1>
            </section>
            <section>
                <p>There comes a time in every investigation when a detective
                    must
                    call upon his trusted allies to join forces and work
                    together.
                    Just as an investigator might depend on the unique skills of
                    his
                    team, so too can JavaScript developers orchestrate multiple
                    operations to execute simultaneously with `Promise.all()`.</p>

                <pre><code>
            const interviewWitness = new Promise((resolve, reject) => {
                // This Promise simulates interviewing a witness
                // ...
            });
        
            const analyzeEvidence = new Promise((resolve, reject) => {
                // This Promise simulates analyzing the evidence
                // ...
            });
        
            const checkAlibi = new Promise((resolve, reject) => {
                // This Promise simulates checking the suspect's alibi
                // ...
            });
        
            Promise.all([interviewWitness, analyzeEvidence, checkAlibi])
            .then(results => {
                console.log(results);  // An array of results from all promises
            })
            .catch(error => {
                console.log(error);
            });
                </code></pre>

                <p>In this example, we have three promises representing
                    different operations: interviewing a witness, analyzing
                    evidence, and checking an alibi. These operations can
                    occur simultaneously - they don't depend on each other's
                    results.</p>

                <p>We use `Promise.all()` to create a single Promise that
                    fulfills when all of the passed Promises have fulfilled.
                    It returns an array of all the values that these
                    Promises were resolved with.</p>

                <p>If any of the passed in Promises has been rejected, then
                    the Promise returned by `Promise.all()` immediately
                    rejects with the reason of the Promise that rejected,
                    whether or not the other Promises have resolved.</p>

            </section>

            <section>
                <h2>Chapter 6</h2>
                <h1>Tracking Down Leads</h1>
            </section>
            <section>
                <p>A lead from a witness can turn into a string of clues, each
                    clue
                    leading to the next until the case is finally solved. In
                    JavaScript, Promises can be chained together in a similar
                    way.
                    Once a Promise resolves, its result can be passed down to
                    the
                    next Promise in the chain.</p>

                <pre><code>
            const initialLead = new Promise((resolve, reject) => {
                // This Promise simulates an initial lead in the investigation
                setTimeout(() => {
                    resolve('First lead');
                }, 2000);
            });
            
            const followUpInvestigation = (lead) => new Promise((resolve, reject) => {
                // This Promise simulates a follow-up investigation based on the initial lead
                setTimeout(() => {
                    resolve(lead + ' -> Followed up');
                }, 2000);
            });
            
            initialLead
            .then(result => {
                return followUpInvestigation(result);  // Pass the result to the next Promise
            })
            .then(finalResult => {
                console.log(finalResult);  // Logs 'First lead -> Followed up'
            })
            .catch(error => {
                console.log(error);
            });
                </code></pre>

                <p>In this example, we first create an initial lead. Once
                    this lead is resolved, the result is passed to a
                    follow-up investigation. The follow-up investigation is
                    a Promise that depends on the result of the initial
                    lead.</p>

                <p>This concept is known as promise chaining. When the
                    `then()` method is called on a Promise, it returns a new
                    Promise. This allows us to chain together multiple
                    `then()` calls, each one running after the previous
                    Promise has resolved.</p>

                <p>If any Promise in the chain is rejected, the `catch()`
                    method at the end of the chain is called. This provides
                    a way to handle errors that may occur in any Promise
                    within the chain.</p>
            </section>
            <section>
                <h2>Chapter 7</h2>
                <h1>The Race Against Time</h1>
            </section>
            <section>
                <p>In every investigation, time is of the essence. Detectives
                    need
                    to follow multiple leads, but sometimes they need to act on
                    the
                    first lead that gives them significant information. This is
                    akin
                    to JavaScript's `Promise.race` method, which helps us handle
                    multiple promises but only care about the one that resolves
                    or
                    rejects first.</p>

                <pre><code>
            const lead1 = new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve('Lead 1 followed');
                }, 5000); // resolves after 5 seconds
            });
        
            const lead2 = new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve('Lead 2 followed');
                }, 3000); // resolves after 3 seconds
            });
        
            const lead3 = new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve('Lead 3 followed');
                }, 4000); // resolves after 4 seconds
            });
        
            Promise.race([lead1, lead2, lead3])
                .then(results => {
                    console.log(results);  // Logs 'Lead 2 followed'
                })
                .catch(error => {
                    console.log(error);
                });
                </code></pre>

                <p>`Promise.race` takes an array of Promises and returns a
                    new Promise that settles as soon as one of the input
                    Promises settles, with the value or reason from that
                    Promise. It's useful when you have multiple asynchronous
                    tasks and you want to commence further operations as
                    soon as the quickest one completes.</p>

                <p>It should be noted that `Promise.race` is not about
                    competition between Promises, it's about first
                    settlement. So if a Promise rejects before all others
                    complete, `Promise.race` will reject and discard all
                    other Promises.</p>

            </section>

            <section>
                <h2>Chapter 8</h2>
                <h1>Revisiting Old Cases</h1>
            </section>
            <section>
                <p>Just as a detective sometimes finds answers in old cases,
                    JavaScript developers have tools that can create
                    already-resolved or already-rejected Promises. These are
                    `Promise.resolve` and `Promise.reject`.</p>

                <pre><code>
            const resolvedCase = Promise.resolve('Case already solved');
            resolvedCase
                .then(result => console.log(result)) // Logs 'Case already solved'
                .catch(error => console.log(error));
        
            const rejectedCase = Promise.reject(new Error('Failed to solve case'));
            rejectedCase
                .then(result => console.log(result))
                .catch(error => console.log(error.message)); // Logs 'Failed to solve case'
                </code></pre>

                <p>`Promise.resolve(value)` returns a Promise object that is
                    resolved with the given value. It can be useful when
                    working with a function that returns a Promise and you
                    want to supply it with a resolved Promise for testing.</p>

                <p>Similarly, `Promise.reject(reason)` returns a Promise
                    object that is rejected with the given reason. This can
                    be useful for testing Promise error paths.</p>

            </section>

            <section>
                <h2>Chapter 9</h2>
                <h1>Back to the Future</h1>
            </section>
            <section>
                <p>Every case is a unique challenge requiring a unique approach.
                    However, certain tools and methodologies become staples in
                    the
                    toolkit of a detective. They are the go-to techniques
                    because
                    they have proved time and again their effectiveness in
                    tackling
                    complex and tangled mysteries. In the realm of JavaScript,
                    `async/await` is one such tool that developers embraced
                    enthusiastically upon its introduction.</p>

                <p>`Async/await` introduced a new dimension to working with
                    Promises, making the asynchronous code look more like
                    synchronous code. This greatly simplifies the process of
                    writing
                    and maintaining complex logic, a feature that is essential
                    when
                    dealing with multi-step asynchronous operations, much like a
                    detective dealing with multi-layered investigations.</p>

                <p>For a detective, using the right approach can make the
                    difference
                    between solving a case or getting stuck in a dead-end. In a
                    similar vein, the ability to use asynchronous code in a
                    synchronous manner opens up a new world of possibilities for
                    JavaScript developers. The `async/await` syntax not only
                    makes
                    the code more readable and easier to understand but also
                    allows
                    developers to handle promises in a way that's more efficient
                    and
                    less error-prone.</p>

                <pre><code>
            async function solveCase() {
                try {
                    const result = await Promise.resolve('Case solved');
                    console.log(result);  // Logs 'Case solved'
                } catch (error) {
                    console.log(error.message);
                }
            }
        
            solveCase();
                </code></pre>

                <p>An `async` function is a function that knows how to
                    expect the possibility of the `await` keyword being used
                    to invoke asynchronous code.</p>

                <p>The `await` keyword is used in an `async` function to
                    ensure that all promises returned in the function are
                    synchronized and await the execution of others to
                    complete. `await` blocks the code execution within the
                    `async` function, it makes the asynchronous code wait
                    until the promise returns a result.</p>

                <p>It makes our code cleaner and easier to understand when
                    compared to using traditional promises and callbacks.</p>

            </section>

            <section>
                <h2>Chapter 10</h2>
                <h1>Closing the case and handling errors</h1>
            </section>
            <section>
                <p>Every detective knows that, despite their best efforts,
                    sometimes
                    things can go wrong. Leads can become dead ends, or the
                    proverbial rug can be pulled out from under their
                    investigation.
                    When such situations arise, it's crucial to know how to
                    handle
                    the fallout and adjust the approach. Similarly, error
                    handling
                    is a critical aspect of writing and managing JavaScript
                    Promises.</p>
                <p>In Promises, error handling is done using the `.catch()`
                    method.
                    This method is invoked when a Promise is rejected or an
                    error is
                    thrown. It's like a safety net that catches the errors and
                    prevents the Promise from failing silently.</p>

                <p>`Async/await` makes error handling even easier and clearer.
                    The
                    errors can be caught using the conventional `try/catch`
                    structure, which most developers are already familiar with
                    from
                    synchronous code.</p>

                <pre><code>
        async function solveCase() {
            try {
                const result = await Promise.reject(new Error('Case unsolvable'));
                console.log(result);
            } catch (error) {
                console.log(error.message);  // Logs 'Case unsolvable'
            }
        }
        
        solveCase();
            </code></pre>

                <p>The above code snippet illustrates how we can catch and
                    handle errors in `async/await`. If the Promise is
                    rejected, the `await` expression throws an exception
                    that can be caught using a `try/catch` block.</p>

                <p>Error handling is a vital part of asynchronous
                    programming. Handling them correctly ensures that your
                    code is robust and resilient, even when things go wrong.</p>

            </section>

            <section>

                <p>I hope this story was helpful! While asynchronous Javascript
                    can
                    be very confusing in the beginning, but with pratice and
                    patience, there is nothing to be afraid of. I <span
                        class="cp">promise</span>!
                </p>

                <p>Yours,</p>
                <p><a href="https://github.com/AndreiChristian" target="_blank">Andrei Christian</a></p>

                <h2>Further resources</h2>
                <ul>
                    <li><a href="https://www.youtube.com/watch?v=RvYYCGs45L4"
                            target="_blank"><h3>Javascript
                                Promise in 100 seconds</h3></a></li>
                    <li><a
                            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#static_properties"
                            target="_blank"><h3>MDN References for Promise</h3></a></li>
                    <li><a
                            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function"
                            target="_blank"><h3>MDN References for Async
                                Functions</h3></a></li>
                    <li><a
                            href="https://www.youtube.com/watch?v=vn3tm0quoqE&t=364s"
                            target="_blank"><h3>The Asycn Await Episode I
                                Promised</h3></a></li>

                </ul>
            </section>

            <script src="app.js"></script>
        </body>
    </html>